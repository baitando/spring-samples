## JPA Data Initialization

For tests of a Spring Boot application, usually an embedded in-memory database is used. To initialize it, there are
mainly two approaches available:

* Use a `schema.sql` and a `data.sql` file. Those files are by convention picked up by Spring Boot to initialize the
  embedded in-memory database.
* Let Hibernate take care of schema generation and initialize the data e.g. using the `TestEntityManager` provided by
  Spring.

The purpose of this sample is to demonstrate both approaches as well as a combination of them. What I experienced is,
that quite many people get confused - especially when both approaches are mixed.

One of the main problems I was facing until now is the order and precedence of the different parts. This is also
documented in a [Spring Boot issue][issue-order] on GitHub.

* The `data.sql` script runs after Hibernate created the schema, if there is no `schema.sql` file available.
* If a `schema.sql` and a `data.sql` file is available, `data.sql` is executed before Hibernate creates the schema.

In addition to this it's important to know, that the schema created with `schema.sql` including the data created
by `data.sql` could disappear depending on the Hibernate setting related to schema generation. The default behavior of
Hibernate when using an embedded database in tests without a schema manager is, that an existing schema is replaced with
the one created by Hibernate. If this is not considered, one may wonder why the data from `data.sql` vanished.

## Scenarios

There are several scenarios covered in this sample:

1. There is a `data.sql` and a `schema.sql` file used. The schema is generated according to `schema.sql`. One data entry
   is created with `data.sql`. There is one data entry in the database.
2. There are no `data.sql` and no `schema.sql` files used. The Schema is generated by Hibernate. One data entry is
   created with the `TestEntityManager`. There is one data entry in the database.
3. There is a `data.sql` and a `schema.sql` file used. Hibernate does not touch the schema. One data entry is created
   with `data.sql` and one with `TestEntityManager`. There are two data entries in the database.
4. There is a `data.sql` and a `schema.sql` file used, but Hibernate also generates the schema and overwrites the schema
   created by `schema.sql`. One data entry is created with `data.sql` and one with `TestEntityManager`. Due to Hibernate
   overwriting the initial schema, the data created by `data.sql` is lost. There is only one data entry in the database.
5. There is a `data.sql` used without a `schema.sql` file. Hibernate creates the schema. One data entry is created
   with `data.sql` and one with `TestEntityManager`. Because of the absence of a `schema.sql` file, the `data.sql`
   script now runs after Hibernate created the schema. There are two data entries in the database.

## How It Is Implemented

To cover the different scenarios mentioned above, the sample is built using the following mechanisms:

* Each scenario has a test with the scenario as suffix of the class name (e.g. `PersonRepositoryTestScenario1`).
* Each scenario test activates a test with named like the scenario (e.g. `scenario1`).
* Each scenario profile has a profile specific configuration file (e.g. `scenario1.yml`).
* Hibernate behavior related to schema generation is configured using the setting `spring.jpa.hibernate.ddl-auto` in the
  scenario configuration file.
* Spring Boot picks up `data.sql` and `schema.sql` files automatically. To get control if it is loaded or not, both
  files were renamed (to `custom-data.sql` and `custom-schema.sql`). The effect is, that those files are not picked up
  automatically. To load them for the relevant scenarios, the file names for the auto-configuration are overwritten in
  the scenario configuration file using the `spring.datasource.schema` and `spring.datasource.data` settings.

[issue-order]: https://github.com/spring-projects/spring-boot/issues/9048
