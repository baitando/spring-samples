## JPA Data Initialization

For tests of a Spring Boot application, usually an embedded in-memory database is used.
To initialize it, there are mainly two approaches available:

* Use a `schema.sql` and a `data.sql` file.
Those files are by convention picked up by Spring Boot to initialize the embedded in-memory database.
* Let the JPA provider take care of schema generation and initialize the data e.g. using the `TestEntityManager` provided by Spring.

The purpose of this sample is to demonstrate both approaches as well as a combination of them.
What I experienced is, that quite many people get confused - especially when both approaches are mixed.

The main problems I was facing yet are:

* There is a data.sql file but no `schema.sql`, because the developer wants to rely on the JPA provider to create the schema.
This won't work, because `schema.sql` and `data.sql` are used for the initialization of the database.
The JPA provider joins the game later, i.e. after the initialization was done.
Therefore the schema is only available at the time when `data.sql` runs, if a proper `schema.sql` is in place.
* There are proper `schema.sql` and `data.sql` files and for some reason there is also a `TestEntityManager` used to create initial data for a test.
In this case you have to explicitly configure the JPA provider behavior related to schema generation.
By default, an existing schema is dropped and a new one is created, if an embedded database is used without a schema manager in place.
If this is not configured explicitly, the initial schema of `schema.sql` and the initial data of `data.sql` are dropped and only the data of the `TestEntityManager` is available.

## Scenarios

There are several scenarios covered in this sample:

1. There is a `data.sql` and a `schema.sql` file used.
The schema is generated according to `schema.sql`.
One data entry is created with `data.sql`.
There is one data entry in the database.
2. There are no `data.sql` and no `schema.sql` files used.
The Schema is generated by the JPA provider.
One data entry is created with the `TestEntityManager`.
There is one data entry in the database.
3. There is a `data.sql` and a `schema.sql` file used.
The JPA provider does not touch the schema.
One data entry is created with `data.sql` and one with `TestEntityManager`.
There are two data entries in the database.
4. There is a `data.sql` and a `schema.sql` file used, but the JPA provider also generates the schema and overwrites the schema created by `schema.sql`.
One data entry is created with `data.sql` and one with `TestEntityManager`.
Due to the JPA provider overwriting the initial schema, the data created by `data.sql` is lost.
There is only one data entry in the database.

## How It Is Implemented

To cover the different scenarios mentioned above, the sample is built using the following mechanisms:

* Each scenario has a test with the scenario as suffix of the class name (e.g. `PersonRepositoryTestScenario1`).
* Each scenario test activates a test with named like the scenario (e.g. `scenario1`).
* Each scenario profile has a profile specific configuration file (e.g. `scenario1.yml`). 
* The JPA provider behavior related to schema generation is configured using the setting `spring.jpa.hibernate.ddl-auto` in the scenario configuration file.
* Spring Boot picks up `data.sql` and `schema.sql` files automatically.
To get control if it is loaded or not, both files were renamed (to `custom-data.sql` and `custom-schema.sql`).
The effect is, that those files are not picked up automatically.
To load them for the relevant scenarios, the file names for the auto-configuration are overwritten in the scenario configuration file using the `spring.datasource.schema` and `spring.datasource.data` settings.